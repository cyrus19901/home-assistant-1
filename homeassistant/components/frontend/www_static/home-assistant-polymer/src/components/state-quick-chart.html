<link rel="import" href="../../bower_components/polymer/polymer.html">
<script src="http://d3js.org/d3.v4.js"></script>
<script src="../../bower_components/moment/min/moment.min.js"></script>


<dom-module id="state-quick-chart">

  <template>
    <style>
        .chart-container {
          padding: 20px;
        }

        .line {
          fill: none;
          stroke: steelblue;
          stroke-width: 2px;
        }
    </style>
    <div class="chart-container">
      <svg id="svg"></svg>
    </div>

  </template>

</dom-module>

<script>
(function () {
  'use strict';

  Polymer({
    is: 'state-quick-chart',

    properties: {
      hass: {
        type: Object,
      },
      chartType: {
        type: String,
        value: ""
      },

      chartLabel: {
        type: String,
        value: ""
      },
      chartId: {
        type: String,
        value: ""
      },
      componentName: {
        type: String,
        value: ""
      },
      updateMethod: {
        type: String,
        value: ""
      },
      unit: {
        type: String,
      },

      isAttached: {
        type: Boolean,
        value: false
      },

      chartEngine: {
        type: Object,
      },

      _apiLoaded: {
        type: Boolean,
        value: false,
      },
      url: {
        type: String,
        value: 'data.csv'
      },
      chartData: {
        type: Object,
        value: {},
        observer: 'dataChanged'
      },
      data: {
        type: Array,
        value: [
          {
            date: '1-May-12',
            close: 68.13,
            open: 34.12
          },
          {
            date: '30-Apr-12',
            close: 63.98,
            open: 45.56
          },
          {
            date: '27-Apr-12',
            close: 67.00,
            open: 67.89
          },
          {
            date: '26-Apr-12',
            close: 89.70,
            open: 78.54
          }
        ]
      }
    },

    dataChanged: function (chartData) {

      if (chartData)
      {
        // this.drawChart();
        switch (this.chartType)
        {
          case 'line':
            const series = Object.keys(chartData.series);
            this.drawChartLine(this.extractData(chartData), series, chartData.series);
            break;
          case 'bar':
            // this.drawChartBar(chartData);
            break;
        }
      }
    },
    createElements: function () {
      var width = 500,
          height = 500,
          radius = Math.min(width, height) / 2;

      this.svg = d3.select(this.$.svg)
          .attr("width", width)
          .attr("height", height)
        .append("g")
          .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");
    },
    drawChartLine: function (data, series, chartInfo) {

      // set the dimensions and margins of the graph
      var margin = {top: 20, right: 20, bottom: 30, left: 50},
          width = 400 - margin.left - margin.right,
          height = 400 - margin.top - margin.bottom;
      
      var svg = d3.select(this.$.svg)
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
        .append("g")
          .attr("transform",
                "translate(" + margin.left + "," + margin.top + ")");

        // set the ranges
        var x = d3.scaleTime().range([0, width]);
        var y = d3.scaleLinear().range([height, 0]);

        // Scale the range of the data
        x.domain(d3.extent(data, function(d) { 
          return d.date; 
        }));
        
        y.domain([0, d3.max(data, function(d) {

          const vals = [];

          series.forEach((key) => {
            if (d[key])
            {
              vals.push(d[key]);
            }
          });

          const max = vals.reduce(function(a, b) {
              return Math.max(a, b);
          });

          return max; 
        })]);

        // Add the X Axis
        svg.append("g")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(x)
              .tickFormat(d3.timeFormat("%m/%d")));

        // Add the Y Axis
        svg.append("g")
            .call(d3.axisLeft(y));

        series.reverse().forEach((key, index) => {

          // var tip = d3.tip()
          //   .attr('class', 'd3-tip')
          //   .offset([-10, 0])
          //   .html(function(d) {
          //     return "<strong>" + key + ":</strong> <span style='color:red'>" + d[key] + "</span>";
          //   })

          // svg.call(tip);

          // var tool_tip = d3.tip()
          //   .attr("class", "d3-tip")
          //   .offset([-8, 0])
          //   .html(function(d) { return "Radius: " + d; });
          // svg.call(tool_tip);

          const drawLine = d3.line()
            .x(function(d) { 
              // console.log('date: ' + d.date);
              return x(d.date); 
            })
            .y(function(d) { 
              // console.log(key + ': ' + d[key]);
              return y(d[key]); 
            })
            .defined(function(d) { return d[key]; });

            svg.append("path")
              .data([data])
              .attr("class", "line")
              .style("stroke", this.colorMap(index))
              .attr("d", drawLine);
              // .on('mouseover', tool_tip.show)
              // .on('mouseout', tool_tip.hide);
        });

    },
    refreshChart: function () {
      var me = this;

      me.g.data(me.pie(me.data))
        .select("path").attr("d", me.arc);

      me.g.select("text")
        .attr("transform", function(d) { 
          console.log("d: " + d);
          console.log("translate(" + me.arc.centroid(d) + ")");
          return "translate(" + me.arc.centroid(d) + ")"; 
        });
    },
    extractData: function (chartData) {
      const data = chartData.times.map((t, index) => {

          const item = {
            date: moment(t).toDate()
          };

          Object.keys(chartData.series).forEach((key) => {
            if (chartData.series[key]['points'][index])
            {
              item[key] = chartData.series[key]['points'][index];
            }
            else
            {
              item[key] = null;
            }
          });

          return item;
      });

      console.log('extracted data: ');
      console.log(data);
      return data;
    },
    ready: function () {
      // this.createElements();
      // // this.getData();
      // this.drawChart();
    },

    created: function () {
      this.style.display = 'block';
    },

    attached: function () {
      this.isAttached = true;
    },
  changeChartType: function (ev) {
    const value = ev.currentTarget.value;

    if (value && this.updateMethod)
    {
      const updateObj = [{ 
        'id': this.chartId,
        'target': 'type',
        'value': value 
      }];
      
      this.callServiceHelper(this.updateMethod, updateObj);
    }
  },
  colorMap: function (index) {
    
    const colors = [
      '#29A6FF', // Celestine +1
      '#E87511', // Carnelian

      '#46A661', // Olivine
      '#00AFAA', // Malachite
      '#EA82FF', // Fluorite +1

      '#FF6B70', // Cinnabar +1

      '#00BDDD', // Zircon +1
      '#AFA1FF', // Amethyst +1
      '#F5EC5A', // Topaz

      '#8CCD5A', // Peridot
      '#FFBA59', // Citrine
      '#BF2A75', // Tourmaline
    ];

    const safeIndex = (colors.length - 1) % (index + 1);

    return colors[safeIndex];
  },
  callServiceHelper: function (service, data) {
    if (this.hass && this.componentName)
    {      
      this.hass.callService(this.componentName, service, { value: data})
        .then(function () {
        }.bind(this));
    }
  },

  });
}());
</script>
